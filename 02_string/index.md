

# 今回から少し難しくなるよ

# 文字列を扱ってみよう

# そのままコードに書いてみよう

# 動かしてみるとどうなる？

# 何が何やら...

# 線形メモリとは？

# 線形メモリに触れてみよう


# 線形メモリ = WASM/ブラウザ共有の仕組み

- WASMの世界とブラウザでデータのやり取りをするための仕組み
- 逆にいうと
  - 関数のin/outか、線形メモリでしかやり取りができない
  - sandboxingの一環でもある

# 線形メモリにデータを入れてみよう

# 線形メモリのデータをWASMから取り出してみよう


# これがやり方(1)

- ブラウザ→WASMインスタンス、の場合

# 逆に: WASMで文字列を作ろう

# ブラウザからその文字列を取り出そう

# これがやり方(2)

- WASMインスタンス→ブラウザ、の場合

# 応用して実装しよう

- WASMによるワードカウントモジュールを作る

# 設計しよう

- フォーム→テキストを取り出す
- テキストデータ→WASMに渡す
- WASM→文字列を復元する
- 数えた数は数値なので、関数の戻り値でOK

# ブラウザ側実装

# Rust側も書いておく

- プロジェクトをもう一つ作る

ダミーの値を返してみよう

# ブラウザ側実装その2

# 一度通しで動かす

ダミーの値がログに出ればOK

# Rust側のワードカウンター

- あくまで一例
- 真面目なエラー処理は...宿題です

# 動作確認しよう

# こんなにめんどくさいの？

## と思ったあなたへの答え

# 実際のWASMの現場では

- wasm-bindgenがラップしてくれます


# あえて低レイヤ、ちょっとめんどくさいやり方をしています

- 抽象度が低い実装に触れることのメリット:
  - 実際の仕事では抽象度の高いツールを使っても理解しやすくなる
  - トラブルシュートやデバッグの解像度が上がる
- このメリットを重視して、やや遠回しだけどなるべく抽象化しないやり方をしています
  - （あくまで勉強なので）

----

<!--
_class: hero
-->

# まとめ

----

# 今日のまとめ

## 以下のような内容を学んだはず

- WASMにおける「文字列」
- 線形メモリの基本
- 実際にテキストデータをやり取りする方法

----

# 次回

- #3 WebAssembly モジュールでより複雑なことをしよう
  - <span style='font-size: 30pt'>予定: 11/XX(TBA) 14:00 start</span>
  - キーワード:
    - 画像処理
    - グレースケール化
